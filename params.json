{"name":"Smash","tagline":"SMArtSHell: python/bash hybrid shell and other hacks for ipython","body":"\r\n===========\r\nAbout SmaSh\r\n===========\r\n\r\nSmaSh is the smart-shell.  It offers features for project management, a flexible plugin\r\narchitecture that is easy to use, and simple JSON configuration files that try to be as\r\nsane as possible.  Python developers might be particularly interested because it also\r\nhappens to be a python/bash hybrid which builds on the pysh profile for IPython.  It builds\r\non, and offers very sophisticated support for python virtual environments.\r\n\r\n\r\n===========\r\nThe Problem\r\n===========\r\n\r\nShells are still annoying!::\r\n\r\n  - No one wants to manage zillions of aliases or arcane readline configurations.\r\n  - Things like sed / awk are great for quick hacks, but are obscure and not maintainable.\r\n  - Shells are not conveniently modular, and do not perform well for things like:\r\n    - multiple projects,\r\n    - multiple use-cases,\r\n    - or domain specific languages.\r\n  - Shells offer only minimal or awkward context-awareness\r\n    - no triggers for things like pre/post \"dir-change\"\r\n    - no hooks for pre/post processing of IO\r\n\r\n\"Do what I mean\" is a pretty reasonable expectation for a modern computer program..\r\nthat's why we get what we expect when we type \"1024*231\" into google, namely a numerical\r\nresult instead of just a bunch of matching webpages.\r\n\r\nType */etc/* into your shell and what do you see?  Probably something like this:::\r\n\r\n   bash:/etc/: Is a directory\r\n\r\nNo kidding.  I even put a \"/\" at the end, so probably I know it is a directory and, in the\r\nabsence of any other context, I probably want to move into that directory.  Or, if I were\r\nto type out the name of a non-executable file that ends in .txt, chances are good I want to\r\nEDIT THE FILE and not see some kind of error about how the file is not executable.\r\n\r\nHow would you even go about fixing something like this in bash, where the interface comes\r\nburdened with so many assumptions?\r\n\r\nOn top of those problems, shells are not at all ideal for software development.  And based\r\non that point, maybe you're already thinking *\"Use emacs/vim/eclipse!\"*.  But, I also\r\npersonally think that a huge, do-everything IDE is not the True Way.\r\n\r\nStill the problems most people solve on a daily basis are similar to the problems from\r\nyesterday, and shell experiences are often characterized by too much repetition.  We fumble with\r\nawkward histories with our control-r's and we do things like build one-off aliases or\r\nscripts and throw them in a *.bashrc* or *~/bin* and there they rot, usually because they\r\nweren't readable a week after they were written, and they weren't quite general enough\r\nto be used everywhere.  Enough is enough!\r\n\r\n====================================\r\nIPython+pysh is not quite a solution\r\n====================================\r\n\r\nIPython is pretty great, but in many ways is more a framework than a solution.  Even though it does\r\nbasic shell stuff, out of the box it is primarily intended for python developers, and not fit for use\r\nas a generic shell.  Here are just a few reasons vanilla IPython and pysh+IPython are not usable as\r\nsystem shells::\r\n\r\n  - obviously not completely bash-like (nor should it be): 'cd <dir>' works but 'tail -f <file>' does not\r\n  - lack of consistency: profiles vs. rc-files vs straight programmatic api configuration is confusing\r\n\r\nAlthough IPython is flexible enough to do almost anything in terms of whatever triggers, aliases, macros,\r\ninput pre/post-processing.. adding fancy stuff on to the IPython core to leverage this functionality\r\n(e.g. via profiles) is *still* not maintainable.\r\n\r\n\r\n=================\r\nVision of a Shell\r\n=================\r\n\r\nWhy do you occasionally go to google to type in things like \"1024 * 768\" or \"cos(53)\" or\r\n\"current time in zimbabwe\"?  And again, why can't it be obvious that typing \"/etc/\" by itself\r\nclearly means \"cd /etc/\"/?  My guess is your shell is just not smart enough, and teaching it\r\nto be smart is not so much difficult as it is simply disorganized.  It takes effort and in the\r\nend it doesn't come out quite the way you hoped.  And that's just for the average user.\r\n\r\nFor developers, what is often needed is an environment that functions simultaneously as a shell\r\nand a sort of sketchbook for programming.  The **pysh** profile for IPython already functions as\r\na sort of Python / Bash chimera, and SmaSh leverages everything it offers:\r\n\r\n  - Simple: all the simplicity of bash when you want it\r\n  - Flexible: all the power of a RealProgrammingLanguage(tm) when you need it\r\n  - Unsurprising: bashy commands and pythony code both work the way you would expect\r\n  - Hybrid: Mixing python and shell code is possible\r\n\r\nSmaSh is also extensible, and actually has very little core functionality.  A big part of what it\r\noffers is just an organized approach to configuration management and plugins.  In fact, almost\r\nall of what it does happens through plugins!  Apart from what the bash/python hybrid features\r\nthat come from pysh, SmaSh also inherits all the flexibility of IPython in terms of I/O hooks\r\nand pre/post processing.  So go nuts with your domain specific language or ruby's pry shell or\r\ngo attach a lisp/lua/node runtime onto this frankenstein bananaphone piano, see if I care.\r\n\r\n================\r\nSmaSh Philosophy\r\n================\r\n\r\nSmaSh is installed and modified on a per-user basis; nothing is installed at the system level.\r\nThis is important because, as you continue to add plugins to smash, any third-party support\r\nlibraries that are required won't clutter up the rest of your system.  In particular,\r\n\r\n   - Installation, including IPython, is completely inside a python virtual-env located at *~/.smash*\r\n   - All configuration is JSON, stored in *~/.smash/etc*\r\n   - All plugins are in *~/.smash/plugins*\r\n   - Core support libraries live in *~/.smash/smashlib*\r\n\r\n==========\r\nSmaSh Core\r\n==========\r\n\r\n\r\nThe Project-management Abstraction:\r\n-----------------------------------\r\n\r\n**Projects** are typically objects that correspond to directories.\r\nProject names should be kept unique.::\r\n\r\n  - Bind individual directories (\"~/myproject\") or directories of directories (\"~/code/\"\")\r\n  - Project configuration is stored with JSON in \"~/.smash/etc/projects.json\"\r\n     - you can manipulate it via the command-line or edit config-files yourself\r\n  - Projects can be \"activated\", \"invoked\", or \"deactivated\" and each can trigger pre/post actions\r\n  - Pre/post actions might mean convenient side-effects such as\r\n     - activating a virtual environment\r\n     - starting a virtual machine\r\n     - opening a web page\r\n     - whatever else you want..\r\n  - Projects can have alias groups\r\n     - alias groups are activated when the project is\r\n     - alias groups are deactivated when you leave the project\r\n  - Projects can be watched for changes, triggers for linters can be added, etc\r\n  - Project code can be searched asynchronously, results shown in a way that doesnt clutter the screen\r\n  - Project code does not necessarily need to be python, but if it is you get sweet benefits\r\n\r\nPrompt and Aliases:\r\n-------------------\r\n\r\n::\r\n\r\n  - Alias configuration is stored with JSON\r\n  - Aliases can be global, or stored per project\r\n  - Aliases that are project specific do not clutter things up when a project is not activated\r\n  - Prompt is split into \"components\" that can be easily added/substracted on the fly, and\r\n  - Prompts can also be project-specific.\r\n\r\nThe Plugin Architecture:\r\n-------------------------\r\n\r\nLots of plugins are included with SmaSh (read more below).  I don't necessarily claim all these\r\nare useful to you, and they won't be enabled by default.  The provided plugins are intended to\r\nprovide a wealth of examples for some of the basic things you might want to do.  SmaSh plugins\r\ncan alter all sorts of things about the environment that they run in.  For example::\r\n\r\n  - loading other plugins\r\n  - altering prompt behaviour\r\n  - altering completion strategies\r\n  - contributing methods, macros, or magic to the shell's global namespace\r\n  - and even alter/act-on command line arguments that SmaSh itself will use.\r\n\r\nPlugins can be enabled unconditionally, in which case they are loaded when SmaSh bootstraps,\r\nor they can be loaded conditionally, in which case they are triggered by project activation\r\nor loaded dynamically by another plugin.\r\n\r\nTo write a plugin you must extend ``smashlib.smash_plugin.SmashPlugin``, and define an install()\r\nmethod.  From the command line you can use **smash --install** to \"acquire\" plugins and move them\r\nto **~/.smash/plugins**.  Plugins can be grabbed from disk, or from URLs but the preferred method\r\nfor distributing plugins is via github gist's using **smash --install gist://<id>**.\r\n\r\nSmaSh tries to encourage writing small plugins without dependencies, but if you need to reuse\r\ncode from another plugin, every plugin that's enabled can be imported at any time from\r\nthe ``smashlib.active_plugins`` module.  If you require a python module that may not be installed\r\nat the system level, make sure your plugin specifies values in ``Plugin.requires_modules``.\r\n\r\nSmaSh plugins can specify any prerequisites they might have in terms of python modules, system\r\nbinaries, or other SmaSh plugins.  At bootstrap, most systems that involve prerequisites use\r\n\"priorities\" for loading dependencies, but *SmaSh is different and drama free*.  You specify\r\nyour prerequisites, and if your configuration is feasible then SmaSh will determine a\r\nconsistent ordering for the bootstrap or tell you if there is a contradiction.\r\n\r\n\r\n=========================\r\nGeneric Plugins for SmaSh\r\n=========================\r\n\r\nDWIM (Do what I mean)::\r\n  - typing \"/etc/\" means \"cd /etc/\"\r\n    - actually, this uses pushd so you can popd back to where you came from\r\n  - typing \"/etc/hosts\" means \"edit /etc/hosts\"\r\n    - only works whenever /etc/hosts/ is not executable\r\n    - shows a warning if you will not be able to save the file\r\n    - editor preferences are defined in ~/.smash/etc/editor.json\r\n    - possible to specify one editor for console, and one for windowing environment\r\n\r\nHostname completion::\r\n\r\n  - works for ssh\r\n  - works for any program using standard URIs like ftp://, http://, etc\r\n  - uses the contents of \"~/.smash/etc/hosts.json\" and, if available, contents of /etc/hosts\r\n\r\nEnhanced Bookmarks::\r\n\r\n  - offers sophisticated bookmarks, globally or per-project\r\n  - bookmark directories, URLs, macros\r\n  - bookmark nonstandard URIs like ssh://person@place\r\n  - launching bookmark actions is keyboard-friendly\r\n\r\nBrowser Integration::\r\n\r\n  - manage and open bookmarks, (global or per-project)\r\n  - performs web searches with http://duckduckgo.com API, allowing for:\r\n    - direct search of stack-overflow, django docs, pypi, etc\r\n    - asynchronous notification that doesnt clutter your display (via growl-style popups)\r\n\r\nGit VCS Integration::\r\n\r\n  - If applicable, default prompt includes current branch name\r\n  - Tab completion including:\r\n     - Branch completion in all the right spots\r\n     - File-system completion when using 'git mv' or 'git add'\r\n     - smart branch/file-system completion when using 'git diff'\r\n  - Various default aliases and places to put more (making \".git/config\" optional)\r\n  - Should you be inclined: hopefully enough abstraction here to easily support other VCS's\r\n\r\nNotification support::\r\n\r\n  - Asynchronous notifications via freedesktop\r\n  - When this works, it's pretty great, but..\r\n     - currently no support for osx (growl)\r\n     - this may involve extra system-level requirements\r\n     - may require some fiddling to get it to work outside of ubuntu/gnome (!)\r\n\r\n=================================\r\nPython Specific Plugins for SmaSh\r\n=================================\r\n\r\nMisc extra completers::\r\n\r\n   - Completers for accessing python dictionaries\r\n   - Completers for setup.py\r\n   - Pip and easy_install completers\r\n      - Completion over the standard pip subcommands\r\n      - Completion over contents of requirements.txt if it's in the working directory\r\n\r\n\r\nVirtual-Environments::\r\n\r\n  - Venv's can be activated/deactivated cleanly, and without lasting side-effects\r\n  - Close integration with projects such that\r\n     - if a project is activated and it is a venv, it will be activated\r\n     - if a project contains a venv at the top-level, that venv will be activated\r\n\r\nFabric integration::\r\n\r\n  - Completion over fabfile commands\r\n  - Programmatic access to the functions themselves\r\n  - PS: this plugin is a good example of a minimal \"post-dir-change\" trigger\r\n\r\nUnit tests::\r\n\r\n  - post-dir-change hook finds `tests/` or `tests.py` in working directory\r\n  - or, scan everything under this working-directory or a known Project\r\n  - attempts to detect what type of unittests these are via static analysis (django/vanilla unittest/etc)\r\n  - test files are enumerated and shortcuts for running them quickly are updated\r\n  - etc\r\n\r\nEnhanced **which** with cascading search behaviour::\r\n\r\n  1) for unix shell commands, \"which\" works as usual\r\n  2) if the name matches a python obj in the global namespace, show the file that defined it\r\n  3) if the name matches an importable module, show the path it would be imported from\r\n  4) if name matches a file, determine file type with file(1)\r\n  5) if name matches a host, show the IP address according to host files\r\n  6) if name matches an internet domain, show the IP address according to DNS\r\n\r\n\r\n==============================\r\nInstallation and Prerequisites\r\n==============================\r\n\r\nSmaSh works well with python 2.6, and 2.7 and possibly earlier.  SmaSh is compatible\r\nwith python3 only insofar as IPython is.  You will need virtualenv installed at the\r\nsystem level ( in debian-based distros, use **apt-get install python-virtualenv**),\r\nbut anything else that is required should be installed automatically by the\r\nfollowing steps.\r\n\r\n  To install, clone this repository::\r\n\r\n    $ mkdir ~/code; cd ~/code\r\n    $ git clone git://github.com/mattvonrocketstein/smash.git\r\n\r\n  Install it (development mode obligatory for now, since SmaSh is beta)::\r\n\r\n    $ python setup.py develop\r\n\r\n  If everything went well, you should be able to run 'smash' now::\r\n\r\n    $ smash\r\n\r\n====================\r\nWorking with Plugins\r\n====================\r\n\r\nBy default, enabled plugins are kept to a minimum.  You can get a list of available,\r\nenabled, and disabled plugins like this::\r\n\r\n    $ smash --list\r\n\r\nIf you use git VCS, I suggest enabling support for that.  This will customize your prompt\r\nto show the current branch, turn on various completers, add convenient aliases.::\r\n\r\n    $ smash --enable git_completers.py\r\n      bootstrap: launching with rc-file: /home/testing/.smash/etc/smash.rc\r\n      git_completer: setting prompt to use git vcs\r\n      project_manager: loading config: /home/testing/.smash/etc/projects.json\r\n      plugin_manager: enabling git_completers.py\r\n\r\nChanges will take affect when you next relaunch the shell.\r\n\r\nIf you're a python programmer, I suggest turning on a few more:::\r\n\r\n    $ smash --enable venv_prompt.py\r\n    $ smash --enable pip_completer.py\r\n    $ smash --enable setup_completer.py\r\n    $ smash --enable which.py\r\n    $ smash --enable fabric_support.py\r\n\r\nFrom inside SmaSh, you can interact with the plugins via the **plugins** command.\r\n(This command is actually an object that represents the plugin manager.  If you\r\nwant the plugin objects themselves use **plugins.plugins**.  If you want the\r\nnamespace defined by a given plugin file, import\r\n**smashlib.active_plugins.some_plugin_name**)::\r\n\r\n    [~]> plugins?\r\n\r\n    Smash-plugin information:\r\n      config-file: /home/matt/.smash/etc/plugins.json\r\n\r\n    |                       name | enabled | errors |\r\n    -------------------------------------------------\r\n    |          apt_completers.py |    True |      0 |\r\n    |     currency_conversion.py |    True |      0 |\r\n    |              djangoisms.py |   False |      0 |\r\n    |          fabric_support.py |   False |      0 |\r\n    |          git_completers.py |    True |      0 |\r\n\r\n=====================\r\nWorking with Projects\r\n=====================\r\n\r\nFirst open *~/.smash/etc/projects.json* in the editor of your choice.\r\n\r\nThe simplest thing you can do is add a single directory as a project.  To do that,\r\nadd a line like this to the \"instructions\" section:::\r\n\r\n   [\"bind\",     [\"~/myproject\"], {}]\r\n\r\nTo add all directories under a certain directory, add an entry like this:::\r\n\r\n   [\"bind_all\", [\"~/code\"],          {}],\r\n\r\nNote that **bind_all** is not recursive, it only goes one layer deep.\r\nOnce you've added this and restarted SmaSh, then it knows about your projects:::\r\n\r\n   matt@vagabond:~$ smash\r\n     bootstrap: launching with rc-file: /home/matt/.smash/etc/smash.rc\r\n     project_manager: loading config: /home/matt/.smash/etc/projects.json\r\n     project_manager: binding /home/matt/code (21 projects found)\r\n   [~]>\r\n\r\nThe shell's handle for interacting with projects is simple \"proj\".  It already\r\nexists there, and you can query it for some simple information like this:::\r\n\r\n   [~]> proj?\r\n\r\n   Found Projects:\r\n   |                 name |                        path | virtualenv |           vcs |\r\n   -----------------------------------------------------------------------------------\r\n   |           robotninja |           ~/code/robotninja |     ./node | GitRepository |\r\n   | readertray-read-only | ~/code/readertray-read-only |        N/A |    Subversion |\r\n   |          plurlpicker |          ~/code/plurlpicker |        N/A |           N/A |\r\n\r\n\r\nYour projects might be registered, but they have not yet declared any post or\r\npre-invocation hooks.  Still, you immediately get a simple alias for changing\r\ndirectories.  Since I have a project called robotninja in my ~/code directory, I can do this::\r\n\r\n   [~]> proj.robotninja\r\n     pre_invoke{'name': u'robotninja'}\r\n   [~/code/robotninja]>\r\n\r\nUseful, but that was kind of boring.  Let's add an alias that means different things\r\ndepending on which project you've activated.  You can see from the table above that\r\none project is using subversion for VCS, whereas another is using git.. so how about\r\nwe make one \"status\" alias that does the right thing in the right place?  Open\r\n*~/.smash/etc/projects.json* again, and make your alias section look something like\r\nthis:::\r\n\r\n  'aliases': {\r\n    'robotninja': ['status git status',],\r\n    'readertray-read-only':['status svn status']\r\n   }\r\n\r\nThe first time when only \"proj.robotninja\" was used, the project was \"invoked\", not\r\n\"activated\".  Activation is accomplished like so:::\r\n\r\n   [~]> proj.robotninja.activate\r\n     pre_invoke{'name': u'robotninja'}\r\n     pre_activate: {'name': u'robotninja'}\r\n     post_activate: {'name': u'robotninja'}\r\n     alias_manager: adding new aliases for \"robotninja\"\r\n     alias_manager:  added 1 aliases for this project\r\n     project_manager: resetting CURRENT_PROJECT\r\n\r\nNote that project \"activation\" implies \"invocation\" in the debugging information\r\nprinted above.  Via *invocation* we changed directories and via *activation* we\r\ngained an alias.::\r\n\r\n   [~/code/robotninja]> status\r\n     # On branch voltron\r\n     # Untracked files:\r\n     #   (use \"git add <file>...\r\n\r\nSo that 'status' alias works as expected.  Let's try the other one..::\r\n\r\n   [~/code/robotninja]> proj.readertray_read_only.activate\r\n     pre_invoke: {'name': u'readertray-read-only'}\r\n     pre_deactivate: {'name': u'robotninja'}\r\n     post_deactivate: {'name': u'robotninja'}\r\n     pre_activate: {'name': u'readertray-read-only'}\r\n     alias_manager: killing old aliases for \"robotninja\"\r\n     alias_manager: removed 1 aliases from the previous project\r\n     post_activate: {'name': u'readertray-read-only'}\r\n     alias_manager: adding new aliases for \"readertray-read-only\"\r\n     alias_manager:  added 1 aliases for this project\r\n     project_manager: resetting CURRENT_PROJECT\r\n\r\n   [~/code/readertray-read-only]> status\r\n     M       readergui.py\r\n\r\nNeato, so shows that the 'status' alias is now attached to subversion rather than git.\r\n\r\n======================\r\nWorking with Bookmarks\r\n======================\r\n\r\nBookmarks are very similar to aliases. blah, blah blah\r\n\r\n=============\r\nRelated Links\r\n=============\r\n\r\n  - ``ipython`` http://ipython.org/ipython-doc/dev/interactive/shell.html\r\n  - ``pysh`` http://faculty.washington.edu/rjl/clawpack-4.x/python/ipythondir/i\r\n  - ``virtualenv for python`` http://some-link-here\r\n\r\n============\r\nOther Shells\r\n============\r\n\r\n  - ``xiki`` (a wiki inspired gui shell) http://xiki.org/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
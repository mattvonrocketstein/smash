#!/usr/bin/env python
#
# you would think that "env python" would work everywhere, but due
# due to interaction with sourced venv's this is actually a tricky
# business.  is it possible for this shell to mess around in multiple
# venv's potentially using multiple python versions?
#

import sys
#execute import smashlib.main
#include ipythonrc

############################################################################
# Load all the actual syntax extensions for shell-like operation, which live
# in the InterpreterExec standard extension.
#import_all IPython.Extensions.InterpreterExec

# TODO: this is overwritten anyway right?  see if i can remove it
from IPython.config.loader import Config
config = Config()
prompt_config=config.PromptManager
prompt_config.in_template = '\C_LightGreen\u@\h\C_LightBlue[\C_LightCyan\Y1\C_LightBlue]\C_Green|\#> '
prompt_config.in2_template = '\C_Green|\C_LightGreen\D\C_Green> '
prompt_config.out_template = '<\#> '

def main():
    import os
    import sys
    sys.path.append(os.path.expanduser('~/.smash/'))
    sys.path.append(os.path.expanduser('~/.smash/plugins'))
    import smashlib
    smashlib.util.report.bootstrap("launching with rc-file: " + smashlib._meta['smash_rc'])
    from IPython.frontend.terminal.embed import InteractiveShellEmbed
    #InteractiveShellEmbed(argv=['-rcfile={0}'.format(smashlib._meta['smash_rc'])])()
    InteractiveShellEmbed(config=config)()
    #IPython.embed()
    #Shell.IPShellEmbed(argv=['-rcfile={0}'.format(smashlib._meta['smash_rc'])])()

if __name__=='__main__':

    try:
        import IPython
    except:
        print ("\nFATAL: cannot run SmaSh.\n"
               "  IPython lib is not available.  \n"
               "    To reproduce this error, try running:\n"
               "      /usr/bin/env python -c\"import IPython\"\n")
        sys.exit(1)
    else:
        main()
